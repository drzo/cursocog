
Creating Custom Atom Types
==========================
The files here demonstrate how to define and use new custom Atom Types.

Projects making use of the AtomSpace often require that some new kind
of data to be represented that does not fit into the basic set of
predefined types. The example used here is chemistry, with the new types
consisting of chemical element names, molecular bonds types and
molecules.

The example is split into two parts: defining the new Atom Types, in
the `demo-types` directory, and examples of using them, in the `apps`
directory.

To create new custom Atom Types, just copy these files to your project,
adjust the various file paths, define the desired types, and build.
That's all there's to it!

Boilerplate
-----------
Almost everything in this demo consists of "boilerplate": a conventional,
fixed pattern containing various configurable file names, file paths and
build parameters. Each of these has to be modified to suit your project,
while maintaining the overall structure.  (Boilerplate is the metal plate
of specifications that is riveted to a steam boiler or other appliance.
You can also think of this code as a "magic incantation": as long as you
stick to the general formula, magic will happen, and everything will be
built correctly.)

The most infuriating part of modifying this to suit your project is that
minor typos in filenames, and forgotten or overlooked stanzas can sink
the entire effort.  All of the names and paths must match precisely,
where-ever they appear.  There's a lot of flexibility here, but if you
are not careful, things just won't work.

demo-types Directory
--------------------
The Atom Types are defined in the `chem_types.script` file. This can be
freely edited to specify new types. Everything needed to use them are
auto-generated by the `CMakefile.txt`. This includes the scheme and Python
bindings. For OCaml bindings, see the `ocaml` directory in the AtomSpace
source code.

The language bindings are exposed in the form of modules: the user only
needs to include the correct module, and the types become usable. The
`demo-types.scm` defines a guile scheme module that exposes the scheme
bindings.  Likewise, the `chempydemo.pyx` defines a (Cython) Python
module that exposes the python bindings. Examples of using both are in
the `apps` directory.

To build everything here, say `make examples` (in the build dir) and
then `sudo make install-demotypes` to install into the root filesystem.

Active Atoms
------------
Included in the demo is a `Carbon14Node`, which provides an example
of an executable Atom. Such Atoms provide a C++ class of the same name,
having a method called `execute()`, which, when called, can execute
arbitrary code. There is a large variety of ways in which execution can
be triggered; this is covered in other demos and is outside he scope of
this one. The demo apps just trigger the execution directly.

It should be obvious as to "what's going one" by reading the code in
`Carbon14Node.cc` and comparing it to what's printed when the demos run.
This file is *completely optional*; custom Atom Types can be used
without making any of them executable.

apps Directory
--------------
Contains short examples of using the demo types.

The `hello-chem.scm` file demos scheme. Run it as
`guile -s hello-chem.scm`

The `chemy-hello.py` file demos python. Run it as
`python3 chemy-hello.py`

The `chemain.cc` file demos C++. Building the examples will build this
file; to run it, run `examples/type-system/apps/cpp-types-demo` from the
build directory.
